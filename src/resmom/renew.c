/*
 * Copyright (C) 1994-2019 Altair Engineering, Inc.
 * For more information, contact Altair at www.altair.com.
 *
 * This file is part of the PBS Professional ("PBS Pro") software.
 *
 * Open Source License Information:
 *
 * PBS Pro is free software. You can redistribute it and/or modify it under the
 * terms of the GNU Affero General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any
 * later version.
 *
 * PBS Pro is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Commercial License Information:
 *
 * For a copy of the commercial license terms and conditions,
 * go to: (http://www.pbspro.com/UserArea/agreement.html)
 * or contact the Altair Legal Department.
 *
 * Altair’s dual-license business model allows companies, individuals, and
 * organizations to create proprietary derivative works of PBS Pro and
 * distribute them - whether embedded or bundled with other software -
 * under a commercial license agreement.
 *
 * Use of Altair’s trademarks, including but not limited to "PBS™",
 * "PBS Professional®", and "PBS Pro™" and Altair’s logos is subject to Altair's
 * trademark licensing policies.
 *
 */

#include <pbs_config.h>   /* the master config generated by configure */

#if defined(PBS_SECURITY) && (PBS_SECURITY == KRB5)

#include "renew.h"

#include "log.h"
#include "pbsgss.h"
#include "mom_func.h"

#include <errno.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <pwd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/fcntl.h>
#include <signal.h>
#include <unistd.h>
#include <math.h>

#include "libpbs.h"
#include "portability.h"
#include "list_link.h"
#include "server_limits.h"
#include "attribute.h"
#include "resource.h"
#include "resmon.h"

#include "rpp.h"
#include "pbs_error.h"

#include "net_connect.h"
#include "dis.h"
#include "batch_request.h"
#include "resource.h"

#include "work_task.h"

#if defined(HAVE_LIBKAFS)
#include <kafs.h>
#elif defined(HAVE_LIBKOPENAFS)
#include <kopenafs.h>
#endif

#include <krb5.h>
#if defined(KRB5_HEIMDAL)
#include <krb5-protos.h>
#endif

#include <com_err.h>

#if defined(KRB525_FALLBACK)
#include <krb525.h>
#include <krb525_convert.h>
#endif

typedef struct eexec_job_info_t {
	int         expire_time;    /* updated according to ticket lifetime */
	time_t      endtime;        /* tickets expiration time */
	krb5_creds  *creds;          /* User's TGT */
	krb5_ccache ccache;         /* User's credentials cache */
	uid_t job_uid;
	char *username;
	char *princ;
	char *jobid;
#if defined(KRB525_FALLBACK)
	char *realm;
#endif
	char *ccache_name;
	krb5_principal client;
} eexec_job_info_t, *eexec_job_info;

struct krb_holder {
	int got_ticket;
	eexec_job_info_t job_info_;
	eexec_job_info job_info;
	krb5_context context;
};

pbs_list_head	svr_allcreds;	/* all credentials received from server */

struct svrcred_data {
	pbs_list_link	cr_link;
	char		*cr_jobid;
	char		*cr_princ;
	krb5_data	*cr_data;
	char		*cr_data_base64; /* used for sending to sis moms*/
};
typedef struct svrcred_data svrcred_data;

enum { MAXTRIES  = 60 };

enum {
	TIME_RESERVE  = 1*60*60,     /* 1 hour */
	TIME_SLEEP    = 2*60,     /* 2 minutes */
	TIME_LIFETIME = 8*60*60   /* 8 hours   */
};

const char *cred_operations[] = { "singleshot", "renewal", "destroy"};

extern  char            *path_jobs; // job directory path
extern struct var_table vtable;
extern time_t	        time_now;

#if defined(KRB525_FALLBACK)
#define PBS_SERVICE ("pbs")
#endif

// local functions
static int get_job_info_from_job(const job *pjob, const task *ptask, eexec_job_info job_info);
static int get_job_info_from_principal(const char *principal, const char* jobid, eexec_job_info job_info);
#if defined(KRB525_FALLBACK)
static krb5_error_code get_ticket_krb525(struct krb_holder *ticket, char *errbuf, size_t errbufsz);
#endif
static krb5_error_code get_ticket_from_storage(struct krb_holder *ticket, char *errbuf, size_t errbufsz);
static krb5_error_code get_ticket_from_ccache(struct krb_holder *ticket, char *errbuf, size_t errbufsz);
static krb5_error_code get_renewed_creds(struct krb_holder *ticket, char *errbuf, size_t errbufsz, int cred_operation);
static int init_ticket(struct krb_holder *ticket, int cred_operation);

extern int decode_block_base64(unsigned char *ascii_data, ssize_t ascii_len, unsigned char *bin_data, ssize_t *p_bin_len, char *msg, size_t msg_len);

/**
 * @brief
 * 	init_ticket_from_req - Initialize a kerberos ticket from request
 *
 * @param[in] principal - kerberos principal
 * @param[in] jobid - job id associated with request
 * @param[out] ticket - Kerberos ticket for initialization
 * @param[in] cred_operation - credentials action type
 *
 * @return 	int
 * @retval	0 on success
 * @retval	!= 0 on error
 */
int init_ticket_from_req(char *principal, char *jobid, struct krb_holder *ticket, int cred_operation) {
	int ret;
	char buf[512];

	if ((ret = get_job_info_from_principal(principal, jobid, ticket->job_info)) != 0) {
		snprintf(buf, sizeof(buf), "Could not fetch GSSAPI information from principal (get_job_info_from_principal returned %d).",ret);
		log_err(errno, "init_ticket_from_req", buf);
		return ret;
	}

	ret = init_ticket(ticket, cred_operation);
	if (ret == 0) {
		ticket->got_ticket = 1;
	}

	return ret;
}

/**
 * @brief
 * 	init_ticket_from_job - Initialize a kerberos ticket from job
 *
 * @param[in] pjob - job structure
 * @param[in] ptask - optional - ptask associated with job
 * @param[out] ticket - Kerberos ticket for initialization
 * @param[in] cred_operation - credentials action type
 *
 * @return 	int
 * @retval	0 on success
 * @retval	!= 0 on error
 */
int init_ticket_from_job(job *pjob, const task *ptask, struct krb_holder *ticket, int cred_operation) {
	int ret;
	char buf[512];

	if ((ret = get_job_info_from_job(pjob, ptask, ticket->job_info)) != 0) {
		snprintf(buf, sizeof(buf), "Could not fetch GSSAPI information from job (get_job_info_from_job returned %d).",ret);
		log_err(errno, "init_ticket_from_job", buf);
		return ret;
	}

	ret = init_ticket(ticket, cred_operation);
	if (ret == 0) {
		ticket->got_ticket = 1;
	}

	return ret;
}

/**
 * @brief
 * 	init_ticket_from_ccache - Initialize a kerberos ticket from ccache file
 *
 * @param[in] pjob - job structure
 * @param[in] ptask - optional - ptask associated with job
 * @param[out] ticket - Kerberos ticket for initialization
 *
 * @return 	int
 * @retval	0 on success
 * @retval	!= 0 on error
 */
int init_ticket_from_ccache(job *pjob, const task *ptask, struct krb_holder *ticket) {
	int ret;
	char buf[512];

	if ((ret = get_job_info_from_job(pjob, ptask, ticket->job_info)) != 0)  {
		snprintf(buf, sizeof(buf), "Could not fetch GSSAPI information from job (get_job_info_from_job returned %d).",ret);
		log_err(errno, "init_ticket_from_job", buf);
		return ret;
	}

	if((ret = krb5_init_context(&ticket->context)) != 0) {
		log_err(ret, "krb5 - init_ticket", "Failed to initialize context.");
		return PBSGSS_ERR_CONTEXT_INIT;
	}

	if ((ret = get_ticket_from_ccache(ticket, buf, 512))) {
		snprintf(buf, sizeof(buf), "Could not get ticket: %s.", error_message(ret));
		log_err(errno, __func__, buf);
		return(ret);
	}

	if (vtable.v_envp != NULL)
		bld_env_variables(&vtable, "KRB5CCNAME", ticket->job_info->ccache_name);
	else
		setenv("KRB5CCNAME",ticket->job_info->ccache_name,1);

	if (ret == 0) {
		ticket->got_ticket = 1;
	}

	return ret;
}

/**
 * @brief
 * 	init_ticket - Initialize a kerberos ticket
 *
 * @param[out] ticket - Kerberos ticket for initialization
 * @param[in] cred_operation - credentials action type
 *
 * @return 	int
 * @retval	PBSGSS_OK on success
 * @retval	!= PBSGSS_OK on error
 */
static int init_ticket(struct krb_holder *ticket, int cred_operation) {
	int ret;
	char buf[512];

	//static char *id = "init_ticket";

#if defined(HAVE_LIBKAFS) || defined(HAVE_LIBKOPENAFS)
	if (cred_operation == CRED_SINGLESHOT) {
		if (k_hasafs())
			k_setpag();
	}
#endif

	if((ret = krb5_init_context(&ticket->context)) != 0) {
		log_err(ret, "krb5 - init_ticket", "Failed to initialize context.");
		return PBSGSS_ERR_CONTEXT_INIT;
	}

	if (cred_operation < CRED_DESTROY) {
		if ((ret = get_renewed_creds(ticket, buf, 512, cred_operation)) != 0) {
			char buf2[512];

			krb5_free_context(ticket->context);
			snprintf(buf2, sizeof(buf2), "get_renewed_creds returned %d, %s",ret, buf);
			log_err(errno, "init_ticket", buf2);
			return PBSGSS_ERR_GET_CREDS;
		}
	}

	if (cred_operation == CRED_DESTROY) {
		if((ret = krb5_cc_resolve(ticket->context, ticket->job_info->ccache_name, &ticket->job_info->ccache))) {
			char buf2[512];

		snprintf(buf2, sizeof(buf2), "Could not resolve ccache name \"krb5_cc_resolve()\" : %s.", error_message(ret));
		log_err(errno, "init_ticket", buf2);
		return(ret);
		}
	}

	if (vtable.v_envp != NULL)
		bld_env_variables(&vtable, "KRB5CCNAME", ticket->job_info->ccache_name);
	else
		setenv("KRB5CCNAME",ticket->job_info->ccache_name,1);

	return PBSGSS_OK;
}

#if defined(HAVE_LIBKAFS) || defined(HAVE_LIBKOPENAFS)
/**
 * @brief
 * 	do_afslog - tests the presence of AFS and do the AFS log if test is true
 *
 * @param[in] context - GSS context
 * @param[in] job_info - eexec_job_info
 *
 * @return 	krb5_error_code
 * @retval	0
 */
krb5_error_code do_afslog(krb5_context context, eexec_job_info job_info) {
	krb5_error_code ret = 0;

	if(k_hasafs() && (ret = krb5_afslog(context, job_info->ccache, NULL, NULL)) != 0) {
		/* ignore this error */
		ret = 0;
	}

	return(ret);
}
#endif

/**
 * @brief
 * 	store_ticket - store the credentials into ccache file
 *
 * @param[in] ticket - ticket with credential
 * @param[out] errbuf - buffer to be filled on error
 * @param[in] errbufsz - size of error buffer
 *
 * @return 	krb5_error_code
 * @retval	0 on success
 * @retval	error code on error
 */
krb5_error_code store_ticket(struct krb_holder *ticket, char *errbuf, size_t errbufsz) {
	krb5_error_code  ret;

	if((ret = krb5_cc_resolve(ticket->context, ticket->job_info->ccache_name, &ticket->job_info->ccache))) {
		snprintf(errbuf, errbufsz, "krb5_store_ticket - Could not resolve cache name \"krb5_cc_resolve()\" : %s.", error_message(ret));
		return(ret);
	}

	if((ret = krb5_cc_initialize(ticket->context, ticket->job_info->ccache, ticket->job_info->creds->client))) {
		snprintf(errbuf, errbufsz, "krb5_store_ticket - Could not initialize cache \"krb5_cc_resolve()\" : %s.", error_message(ret));
		return(ret);
	}

	if((ret = krb5_cc_store_cred(ticket->context, ticket->job_info->ccache, ticket->job_info->creds))) {
		snprintf(errbuf, errbufsz, "krb5_store_ticket - Could not store credentials initialize cache \"krb5_cc_resolve()\" : %s.", error_message(ret));
		return(ret);
	}

	return(0);
}

/**
 * @brief
 * 	get_renewed_creds - Get and store renewed credentials for a given ticket.
 *	The credentilas are obtained from storage (which is the memory) and stored
 *	into ccache file.
 *
 * @param[in] ticket - ticket for which to get and store credentials
 * @param[out] errbuf - buffer to be filled on error
 * @param[in] errbufsz - size of error buffer
 * @param[in] cred_operation - type of operation with credentials
 *
 * @return 	krb5_error_code
 * @retval	0 on success
 * @retval	error code on error
 */
static krb5_error_code get_renewed_creds(struct krb_holder *ticket, char *errbuf, size_t errbufsz, int cred_operation) {
	krb5_error_code ret;
	char strerrbuf[512];

	/* Get TGT for user */
	if ((ret = get_ticket_from_storage(ticket, errbuf, errbufsz)) != 0) {
#if defined(KRB525_FALLBACK)
		log_record(PBSEVENT_DEBUG, PBS_EVENTCLASS_JOB, LOG_DEBUG, ticket->job_info->jobid, "no credentials supplied, krb525_fallback");

		/* krb525_fallback */
		if ((ret = get_ticket_krb525(ticket,errbuf,errbufsz)) != 0)
			return ret;
#else
		log_record(PBSEVENT_DEBUG, PBS_EVENTCLASS_JOB, LOG_DEBUG, ticket->job_info->jobid, "no credentials supplied");
		return ret;
#endif
	}

	/* Go user */
	if(seteuid(ticket->job_info->job_uid) < 0) {
		strerror_r(errno,strerrbuf,512);
		snprintf(errbuf, errbufsz, "krb5_get_renewed_creds - Could not set uid using \"setuid()\": %s.", strerrbuf);
		return errno;
	}

	/* Store TGT */
	if((ret = store_ticket(ticket, errbuf, errbufsz))) {
		seteuid(0);
		return ret;
	}

#if defined(HAVE_LIBKAFS) || defined(HAVE_LIBKOPENAFS)
	/* Login to AFS cells  */
	/* log to AFS only on creation; logging to AFS for renew must be done through a forked process */
	if (cred_operation == CRED_SINGLESHOT) {
		if((ret = do_afslog(ticket->context, ticket->job_info))) {
			seteuid(0);
			return ret;
		}
	}
#endif

   /* Go root */
	if(seteuid(0) < 0) {
		strncpy(errbuf,"krb5_get_renewed_creds - Could reset root priviledges.",errbufsz);
		return errno;
	}

	return 0;
}

/**
 * @brief
 * 	get_ticket_from_storage - Acquire a user ticket. The credentials are
 *	expected to be stored in the mom's memory (supplied by the pbs server). 
 *
 * @param[in] ticket - ticket to be filled with credentials
 * @param[out] errbuf - buffer to be filled on error
 * @param[in] errbufsz - size of error buffer
 *
 * @return 	krb5_error_code
 * @retval	0 on success
 * @retval	error code on error
 */
static krb5_error_code get_ticket_from_storage(struct krb_holder *ticket, char *errbuf, size_t errbufsz) {
	krb5_error_code ret = 0;
	krb5_auth_context auth_context = NULL;
	krb5_creds **creds = NULL;
	krb5_data *datatmp;
	krb5_data *data;
	int32_t flags;

	datatmp = find_cred_by_jobid(ticket->job_info->jobid);
	if (datatmp == NULL) {
		snprintf(errbuf, errbufsz, "find_cred_by_jobid failed; no credentials supplied for job: %s", ticket->job_info->jobid);
		ret = KRB5_NOCREDS_SUPPLIED;
		goto out;
	}

	if ((ret = krb5_copy_data(ticket->context, datatmp, &data))) {
		const char *krb5_err = krb5_get_error_message(ticket->context, ret);
		snprintf(errbuf, errbufsz, "krb5_copy_data failed; Error text: %s", krb5_err);
		krb5_free_error_message(ticket->context, krb5_err);
		goto out;
	}

	if ((ret = krb5_auth_con_init(ticket->context, &auth_context))) {
		const char *krb5_err = krb5_get_error_message(ticket->context, ret);
		snprintf(errbuf, errbufsz, "krb5_auth_con_init failed; Error text: %s", krb5_err);
		krb5_free_error_message(ticket->context, krb5_err);
		goto out;
	}

	krb5_auth_con_getflags(ticket->context, auth_context, &flags);
	flags &= ~(KRB5_AUTH_CONTEXT_DO_TIME);
#if defined(KRB5_HEIMDAL)
	flags |= KRB5_AUTH_CONTEXT_CLEAR_FORWARDED_CRED;
#endif
	krb5_auth_con_setflags(ticket->context, auth_context, flags);

	if ((ret = krb5_rd_cred(ticket->context, auth_context, data , &creds, NULL))) {
		const char *krb5_err = krb5_get_error_message(ticket->context, ret);
		snprintf(errbuf,errbufsz, "krb5_rd_cred - reading credentials; Error text: %s", krb5_err);
		krb5_free_error_message(ticket->context, krb5_err);
		goto out;
	}

	ticket->job_info->creds = creds[0];

	ticket->job_info->endtime = ticket->job_info->creds->times.endtime;

	if (ticket->job_info->endtime < time_now)
		return KRB5_NOCREDS_SUPPLIED;

out:
	return ret;
}

/**
 * @brief
 * 	get_ticket_from_ccache - Acquire a user ticket. The credentials are
 *	read from ccache file. 
 *
 * @param[in] ticket - ticket to be filled with credentials
 * @param[out] errbuf - buffer to be filled on error
 * @param[in] errbufsz - size of error buffer
 *
 * @return 	krb5_error_code
 * @retval	0 on success
 * @retval	error code on error
 */
static krb5_error_code get_ticket_from_ccache(struct krb_holder *ticket, char *errbuf, size_t errbufsz) {
	krb5_error_code ret = 0;
	krb5_creds *mcreds = NULL;
	int32_t flags;
	krb5_auth_context auth_context = NULL;

	mcreds = malloc(sizeof(krb5_creds));
	memset(mcreds, 0, sizeof(krb5_creds));

	if((ret = krb5_copy_principal(ticket->context, ticket->job_info->client, &mcreds->client))) {
		const char *krb5_err = krb5_get_error_message(ticket->context, ret);
		snprintf(errbuf, errbufsz,"krb5_get_ticket - couldn't copy client principal - (%s)", krb5_err);
		krb5_free_error_message(ticket->context, krb5_err);
		goto out;
	}

	if((ret = krb5_cc_resolve(ticket->context, ticket->job_info->ccache_name, &ticket->job_info->ccache))) {
		const char *krb5_err = krb5_get_error_message(ticket->context, ret);
		snprintf(errbuf, errbufsz, "krb5_cc_resolve failed; Error text: %s", krb5_err);
		krb5_free_error_message(ticket->context, krb5_err);
		goto out;
	}

	if ((ret = krb5_auth_con_init(ticket->context, &auth_context))) {
		const char *krb5_err = krb5_get_error_message(ticket->context, ret);
		snprintf(errbuf, errbufsz, "krb5_auth_con_init failed; Error text: %s", krb5_err);
		krb5_free_error_message(ticket->context, krb5_err);
		goto out;
	}

	krb5_auth_con_getflags(ticket->context, auth_context, &flags);
	flags &= ~(KRB5_AUTH_CONTEXT_DO_TIME);
#if defined(KRB5_HEIMDAL)
	flags |= KRB5_AUTH_CONTEXT_CLEAR_FORWARDED_CRED;
#endif
	krb5_auth_con_setflags(ticket->context, auth_context, flags);

	if ((ret = krb5_cc_retrieve_cred(ticket->context, ticket->job_info->ccache, flags, mcreds, ticket->job_info->creds))) {
		const char *krb5_err = krb5_get_error_message(ticket->context, ret);
		snprintf(errbuf, errbufsz, "krb5_cc_retrieve_cred failed; Error text: %s", krb5_err);
		krb5_free_error_message(ticket->context, krb5_err);
		goto out;
	}

	ticket->job_info->endtime = ticket->job_info->creds->times.endtime;

out:
	krb5_free_creds(ticket->context, mcreds);
	return(ret);
}

/**
 * @brief
 * 	get_ticket_ccname - Get ccname file name from ticket
 *
 * @param[in] ticket
 *
 * @return 	char
 * @retval	ccache file
 * @retval	NULL on error
 */
char *get_ticket_ccname(struct krb_holder *ticket) {
	if (ticket == NULL || ticket->job_info == NULL)
		return NULL;

	return ticket->job_info->ccache_name;
}

#if defined(KRB525_FALLBACK)
static volatile sig_atomic_t received_signal = 0;

static void register_signal(int signal) {
	received_signal = signal;
}

/** Kerberos ticket renewal loop
 *
 * @param ticket Ticket to be periodically renewed
 * @return PBSGSS_OK (errors are logged into syslog)
 */
static int do_renewal(struct krb_holder *ticket) {
	// initialize signal catcher
	struct sigaction sa;
	memset(&sa,0,sizeof(sa));
	sa.sa_handler = register_signal;
	sigaction(SIGTERM, &sa, NULL);
	sa.sa_handler = SIG_IGN;
	sigaction(SIGHUP, &sa, NULL);


	int errs = 0;
	while (received_signal == 0) {
		krb5_timestamp now;
		if (krb5_timeofday(ticket->context, &now) != 0) {
#if SYSLOG
			syslog(LOG_ERR, "KRB5 Renewal process failed for %s. krb5_timeofday() failed in pid %d.", ticket->job_info->ccache_name, getpid());
#endif
			continue;
		}

		if(now < ticket->job_info->endtime - TIME_RESERVE) {
			sleep(TIME_SLEEP);
			continue;
		}

		char errbuf[512];
		size_t errbufsz = 512;

		int ret = get_renewed_creds(ticket,errbuf,errbufsz, CRED_SINGLESHOT);
		if (ret != PBSGSS_OK) {
#if SYSLOG
			syslog(LOG_ERR, "KRB5 Renewal process failed for %s. get_renewed_creds() failed in pid %d. Error: %s", ticket->job_info->ccache_name, getpid(), errbuf);
#endif
			if (errs < 5) errs++;

			static const unsigned sleep_times[] = { 5, 15, 30, 120, 300, 300 };
			sleep(sleep_times[errs]);
		} else {
			errs = 0;
		}
	}

	free_ticket(ticket, CRED_DESTROY);

	return PBSGSS_OK;
}

/** @brief Start the ticket renewal process
 *
 * @param ptask Task for which to start the process
 * @param fd1 process write file descriptor
 * @param fd2 process read file descriptor
 * @return PBSGSS_OK on success, PBSGSS_ERR_* otherwise
 */
int start_renewal(const task *ptask, int fd1, int fd2) {
	if (ptask == NULL)
		return PBSGSS_ERR_INTERNAL;

	job *pjob = ptask->ti_job;

	char pid_file[MAXPATHLEN];
	if (*pjob->ji_qs.ji_fileprefix != '\0')
		snprintf(pid_file, sizeof(pid_file), "%s%s_renew_%ld.pid", path_jobs, pjob->ji_qs.ji_fileprefix, (long)ptask->ti_qs.ti_task);
	else
		snprintf(pid_file, sizeof(pid_file), "%s%s_renew_%ld.pid", path_jobs, pjob->ji_qs.ji_jobid, (long)ptask->ti_qs.ti_task);

	int fd = open(pid_file, O_CREAT|O_EXCL|O_WRONLY, 0600);
	if (fd == -1) {
		char buf[512];
		/* another renewal process is running ? */
		snprintf(buf, sizeof(buf), "opening PID file for renewal process (%s) uid = %d", pid_file, getuid());
		log_err(errno, "krb5_start_renewal", buf);
		return PBSGSS_ERR_CANT_OPEN_FILE;
	}

	struct krb_holder *ticket = alloc_ticket();
	if (ticket == NULL)
		return PBSGSS_ERR_INTERNAL;

	int ret = init_ticket_from_job(pjob,ptask,ticket, CRED_SINGLESHOT);
	if (ret == PBSGSS_ERR_NO_KRB_PRINC) {/* job without a principal */
		close(fd); // not an error, but do not start renewal
		return 0;
	}

	if (ret != 0) {/* error */
		close(fd);
		return ret;
	}


	int pid = fork();
	if (pid < 0) {
		if(ticket->job_info->ccache) {
			krb5_cc_destroy(ticket->context, ticket->job_info->ccache);
			unlink(ticket->job_info->ccache_name);
		}

		log_err(errno, "krb5_start_renewal", "fork() failed");
		close(fd);
		return PBSGSS_ERR_INTERNAL;
	}

	if (pid > 0) {
		char buf[512];
		snprintf(buf, sizeof(buf), "%d\n", pid);
		ret = write(fd, buf, strlen(buf));
		if (ret == -1) {
			log_err(errno, "krb5_start_renewal", "writing pid failed");
			goto out;
		}

		log_record(PBSEVENT_DEBUG, PBS_EVENTCLASS_JOB, LOG_DEBUG, "krb5_start_renewal", "renewal started");
		ret = PBSGSS_OK;

out:
		if (ret == -1) {
			if(ticket->job_info->ccache) {
				krb5_cc_destroy(ticket->context, ticket->job_info->ccache);
				unlink(ticket->job_info->ccache_name);
			}
			unlink(pid_file);

			ret = PBSGSS_ERR_INTERNAL;
		}

		if (fd != -1) {
			fsync(fd);
			close(fd);
		}

		return ret;
	}

	close(fd);
	if (fd1 >= 0)
		close(fd1);
	if (fd2 >= 0)
		close(fd2);
	if (setsid() == -1)
		log_record(PBSEVENT_DEBUG, PBS_EVENTCLASS_JOB, LOG_DEBUG, __func__, "could not setsid");

	// start the actual renewal process
	do_renewal(ticket);

	exit(0);
}

/** Stop the renewal process for a given task
 *
 * @param ptask Task for which the renewal process should be stopped
 * @return PBSGSS_OK on success, PBSGSS_ERR_* on error
 */
int stop_renewal(const task *ptask) {
	if (ptask == NULL)
		return PBSGSS_ERR_INTERNAL;

	job *pjob = ptask->ti_job;
	if (pjob == NULL)
		return PBSGSS_ERR_INTERNAL;

	char pid_file[1024];
	if (*pjob->ji_qs.ji_fileprefix != '\0')
		snprintf(pid_file, sizeof(pid_file), "%s%s_renew_%ld.pid", path_jobs, pjob->ji_qs.ji_fileprefix, (long)ptask->ti_qs.ti_task);
	else
		snprintf(pid_file, sizeof(pid_file), "%s%s_renew_%ld.pid", path_jobs, pjob->ji_qs.ji_jobid, (long)ptask->ti_qs.ti_task);

	FILE *fd;
	fd = fopen(pid_file, "r");
	if (fd == NULL)
		return PBSGSS_ERR_CANT_OPEN_FILE;

	int pid = 0;
	if (fscanf(fd, "%d", &pid) < 1) {
		pid = -1;
	}

	fclose(fd);

	if (pid >= 0) {
		if (kill(pid, SIGTERM) != 0)
			return PBSGSS_ERR_KILL_RENEWAL_PROCESS;
	} else {
		return PBSGSS_ERR_KILL_RENEWAL_PROCESS;
	}

	struct stat cache_info;

	if (stat(pid_file, &cache_info) == 0) {
		unlink(pid_file);
	}

	return PBSGSS_OK;
}
#endif

/**
 * @brief
 * 	got_ticket - Determine whether the supplied ticket was initialized
 *
 * @param[in] ticket
 *
 * @return 	int
 * @retval	True - if ticket has been initialized
 * @retval	False - otherwise
 */
int got_ticket(struct krb_holder *ticket) {
	return ticket->got_ticket;
}

/**
 * @brief
 * 	got_ticket - Allocated a new krb_holder structure (ticket)
 *
 * @return 	krb_holder
 * @retval	structure - on success
 * @retval	NULL - otherwise
 */
struct krb_holder *alloc_ticket() {
	struct krb_holder *ticket = (struct krb_holder*)(calloc(1,sizeof(struct krb_holder)));
	if (ticket == NULL)
		return NULL;

	ticket->job_info = &ticket->job_info_;

	ticket->job_info->creds = malloc(sizeof(krb5_creds));
	memset(ticket->job_info->creds, 0, sizeof(krb5_creds));

	return ticket;
}

/**
 * @brief
 * 	free_ticket - Free a kerberos ticket. Distinguishes whether the
 *	credentials should be also destroyed (removed ccache) or only
 *	free the structures.
 *
 * @param[in] ticket - Ticket with context and job info information
 * @param[in] cred_operation - requested operation
 *
 */
void free_ticket(struct krb_holder *ticket, int cred_operation) {
	krb5_error_code ret = 0;

	if (ticket == NULL)
		return;

	if (ticket->got_ticket) {
		if (cred_operation == CRED_DESTROY && ticket->job_info->ccache) {
			if ((ret = krb5_cc_destroy(ticket->context, ticket->job_info->ccache))) {
				const char *krb5_err = krb5_get_error_message(ticket->context, ret);
				log_err(ret, __func__, krb5_err);
				krb5_free_error_message(ticket->context, krb5_err);
			}

			unlink(ticket->job_info->ccache_name);
		}

		krb5_free_creds(ticket->context,ticket->job_info->creds);
		krb5_free_principal(ticket->context,ticket->job_info->client);
		krb5_free_context(ticket->context);

#if defined(HAVE_LIBKAFS) || defined(HAVE_LIBKOPENAFS)
		if (cred_operation == CRED_DESTROY && k_hasafs())
			k_unlog();
#endif

	}

	free(ticket->job_info->ccache_name);
	free(ticket->job_info->princ);
#if defined(KRB525_FALLBACK)
	free(ticket->job_info->realm);
#endif
	free(ticket->job_info->username);

	free(ticket);
}

/**
 * @brief
 * 	get_job_info_from_job - Fill in job info from job structure
 *
 * @param[in] pjob - job structure
 * @param[in] ptask - optional ptask associated with job process
 * @param[out] job_info - filled job information
 *
 * @return 	int
 * @retval	PBSGSS_OK - on sucess
 * @retval	!= PBSGSS_OK - on error
 */
static int get_job_info_from_job(const job *pjob, const task *ptask, eexec_job_info job_info) {
	char *principal = NULL;

	if (pjob->ji_wattr[(int)JOB_ATR_krb_princ].at_flags & ATR_VFLAG_SET)
		principal = strdup(pjob->ji_wattr[(int)JOB_ATR_krb_princ].at_val.at_str);
	else {
		log_err(-1, "krb5_get_job_info_from_job", "No ticket found on job.");
		return PBSGSS_ERR_NO_KRB_PRINC;
	}

	if (principal == NULL) // memory allocation error
		return PBSGSS_ERR_INTERNAL;

	size_t len;
	char *ccname = NULL;
	if (ptask == NULL) {
		len = snprintf(NULL,0,"FILE:/tmp/krb5cc_pbsjob_%s", pjob->ji_qs.ji_jobid);
		ccname = (char*)(malloc(len+1));
		if (ccname != NULL)
			snprintf(ccname,len+1,"FILE:/tmp/krb5cc_pbsjob_%s", pjob->ji_qs.ji_jobid);
	} else {
		len = snprintf(NULL,0,"FILE:/tmp/krb5cc_pbsjob_%s_%ld", pjob->ji_qs.ji_jobid, (long)ptask->ti_qs.ti_task);
		ccname = (char*)(malloc(len+1));
		if (ccname != NULL)
			snprintf(ccname,len+1,"FILE:/tmp/krb5cc_pbsjob_%s_%ld", pjob->ji_qs.ji_jobid, (long)ptask->ti_qs.ti_task);
	}

	if (ccname == NULL) {// memory allocation error
		free(principal);
		return PBSGSS_ERR_INTERNAL;
	}

	if (pjob->ji_wattr[(int)JOB_ATR_euser].at_val.at_str == NULL) {
		free(principal);
		free(ccname);
		return PBSGSS_ERR_NO_USERNAME;
	}

	char *username = strdup(pjob->ji_wattr[(int)JOB_ATR_euser].at_val.at_str);
	if (username == NULL) {
		free(principal);
		free(ccname);
		return PBSGSS_ERR_INTERNAL;
	}

	krb5_context context;
	krb5_init_context(&context);
	krb5_parse_name(context,principal,&job_info->client);

#if defined(KRB525_FALLBACK)
	const char * realm = krb5_principal_get_realm(context,job_info->client);
	if (realm == NULL || (job_info->realm = strdup(realm)) == NULL) {
		free(principal);
		free(ccname);
		free(username);
		krb5_free_context(context);
		return PBSGSS_ERR_INTERNAL;
	}
#endif

	krb5_free_context(context);

	job_info->princ = principal;
	job_info->ccache_name = ccname;
	job_info->username = username;
	job_info->job_uid = pjob->ji_qs.ji_un.ji_momt.ji_exuid;

	job_info->jobid = strdup(pjob->ji_qs.ji_jobid);
	if (job_info->jobid == NULL) {
		free(principal);
		free(ccname);
		return PBSGSS_ERR_INTERNAL;
	}

	return PBSGSS_OK;
}

/**
 * @brief
 * 	get_job_info_from_principal - Fill in job info from a principal
 *
 * @param[in] principal - Principal for which to construct job info
 * @param[in] jobid - Job ID for which to construct job info
 * @param[out] job_info - filled job information
 *
 * @return 	int
 * @retval	PBSGSS_OK - on sucess
 * @retval	!= PBSGSS_OK - on error
 */
static int get_job_info_from_principal(const char *principal, const char* jobid, eexec_job_info job_info) {
	if (principal == NULL) {
		log_err(-1, "krb5_get_job_info_from_principal", "No principal provided.");
		return PBSGSS_ERR_NO_KRB_PRINC;
	}

	char *princ = strdup(principal);
	if (princ == NULL)
		return PBSGSS_ERR_INTERNAL;

	char login[PBS_MAXUSER+1];
	strncpy(login, principal, PBS_MAXUSER+1);
	char *c = strchr(login, '@');
	if (c != NULL)
		*c = '\0';

	// get users uid
	struct passwd pwd;
	struct passwd *result;
	char *buf;
	long int bufsize;

	bufsize = sysconf(_SC_GETPW_R_SIZE_MAX);
	if (bufsize == -1)          /* Value was indeterminate */
		bufsize = 16384;          /* Should be more than enough */

	if ((buf = (char*)(malloc(bufsize))) == NULL) {
		free(princ);
		return PBSGSS_ERR_INTERNAL;
	}

	int ret = getpwnam_r(login, &pwd, buf, bufsize, &result);

	if (result == NULL) {
		free(princ);
		free(buf);
		if (ret == 0)
			return PBSGSS_ERR_USER_NOT_FOUND;
		else
			return PBSGSS_ERR_INTERNAL;
	}

	uid_t uid = pwd.pw_uid;
	free(buf);

	char *username = strdup(login);
	if (username == NULL) {
		free(princ);
		return PBSGSS_ERR_INTERNAL;
	}

	size_t len;
	char *ccname;
	len = snprintf(NULL, 0, "FILE:/tmp/krb5cc_pbsjob_%s", jobid);
	ccname = (char*)(malloc(len+1));
	if (ccname != NULL)
		snprintf(ccname, len+1, "FILE:/tmp/krb5cc_pbsjob_%s", jobid);

	if (ccname == NULL) {
		free(princ);
		free(username);
	}

	krb5_context context;
	krb5_init_context(&context);
	krb5_parse_name(context, principal, &job_info->client);

#if defined(KRB525_FALLBACK)
	const char * realm = krb5_principal_get_realm(context,job_info->client);
	if (realm == NULL || (job_info->realm = strdup(realm)) == NULL) {
		free(princ);
		free(ccname);
		free(username);
		return PBSGSS_ERR_INTERNAL;
	}
#endif

	krb5_free_context(context);

	job_info->princ = princ;
	job_info->job_uid = uid;
	job_info->username = username;
	job_info->ccache_name = ccname;

	job_info->jobid = strdup(jobid);
	if (job_info->jobid == NULL) {
		free(princ);
		free(ccname);
		free(username);
		return PBSGSS_ERR_INTERNAL;
	}

	return PBSGSS_OK;
}

/**
 * @brief
 * 	cred_by_job - renew/create or destroy credential associated with job id
 *
 * @param[in] pjob - job structure
 * @param[in] cred_operation - type of action (renewal, destroy)
 *
 * @return 	int
 * @retval	PBSGSS_OK - on sucess
 * @retval	!= PBSGSS_OK - on error
 */
int cred_by_job(job *pjob, int cred_operation){
	struct krb_holder *ticket = NULL;
	int ret;

	ticket = alloc_ticket();
	if (ticket == NULL)
		return PBSGSS_ERR_INTERNAL;

	ret = init_ticket_from_job(pjob, NULL, ticket, cred_operation);
	if (ret == PBSGSS_ERR_NO_KRB_PRINC) {
		/* job without a principal */
		/* not an error, but do nothing */
		return PBSGSS_OK;
	}

	if (ret == PBSGSS_OK) {
		sprintf(log_buffer, "%s for %s succeed",
			cred_operations[cred_operation],
			ticket->job_info->ccache_name);
		log_record(PBSEVENT_DEBUG, PBS_EVENTCLASS_JOB, LOG_DEBUG, pjob->ji_qs.ji_jobid, log_buffer);
	} else {
		sprintf(log_buffer, "%s for %s failed with error: %d",
			cred_operations[cred_operation],
			ticket->job_info->ccache_name,
			ret);
		log_record(PBSEVENT_ERROR, PBS_EVENTCLASS_JOB, LOG_DEBUG, pjob->ji_qs.ji_jobid, log_buffer);
	}

	free_ticket(ticket, cred_operation);

	return ret;
}

#if defined(HAVE_LIBKAFS) || defined(HAVE_LIBKOPENAFS)
/**
 * @brief
 * 	redo_afslog - send HUP signal to forked process associated with
 *	job work task in order to do AFS log
 *
 * @param[in] pwt - job work task
 *
 */
void redo_afslog(struct work_task *pwt) {
	const task *ptask = (const task *)pwt->wt_parm1;

#if defined(KRB525_FALLBACK)
	/* krb525_fallback zacatek - overime, zda neexistuje stary pid file, pokud ano tak koncime */
	job *pjob = ptask->ti_job;
	if (pjob) {

		char pid_file[1024];
		if (*pjob->ji_qs.ji_fileprefix != '\0')
			snprintf(pid_file, sizeof(pid_file), "%s%s_renew_%ld.pid", path_jobs, pjob->ji_qs.ji_fileprefix, (long)ptask->ti_qs.ti_task);
		else
			snprintf(pid_file, sizeof(pid_file), "%s%s_renew_%ld.pid", path_jobs, pjob->ji_qs.ji_jobid, (long)ptask->ti_qs.ti_task);

		FILE *fd;
		fd = fopen(pid_file, "r");
		if (fd != NULL) {
			int pid = 0;
			if (fscanf(fd, "%d", &pid) < 1) {
				pid = -1;
			}

			fclose(fd);

			if (pid >= 0)
				return; /* mame stary pid, jde o task ze stare mamy - konec */
		}
	}
	/* krb525_fallback konec */
#endif

	int ret = signal_afslog(ptask, SIGHUP);
	if (ret) {
		sprintf(log_buffer, "afslog failed for task: %8.8X",
			ptask->ti_qs.ti_task);
			log_record(PBSEVENT_ERROR, PBS_EVENTCLASS_JOB, LOG_ERR,
			ptask->ti_job->ji_qs.ji_jobid, log_buffer);
	}
}
#endif

/**
 * @brief
 * 	renew_job_cred - renew credentials for job and also do the AFS log
 *	for all work tasks associated with the job. The AFS log need to be done
 *	in forked process. The AFS log also need to be spread in time in order
 *	not to do AFS log simultaneously.
 *
 * @param[in] pjob - job structure
 *
 * @return 	int
 * @retval	PBSGSS_OK - on sucess
 * @retval	!= PBSGSS_OK - on error
 */
int renew_job_cred(job *pjob) {

	int ret = 0;

	if ((ret = cred_by_job(pjob, CRED_RENEWAL)) != PBSGSS_OK) {
		sprintf(log_buffer, "renewal failed, error: %d", ret);
		log_record(PBSEVENT_ERROR, PBS_EVENTCLASS_JOB, LOG_ERR,
			pjob->ji_qs.ji_jobid, log_buffer);
		return ret;
	}

#if defined(HAVE_LIBKAFS) || defined(HAVE_LIBKOPENAFS)
	pbs_task	*ptask;
	int spread_afslog_signal = 0;
	for (ptask = (pbs_task *)GET_NEXT(pjob->ji_tasks);
				ptask;
				ptask = (pbs_task *)GET_NEXT(ptask->ti_jobtask)) {
		if (ptask->ti_job == pjob && ptask->ti_qs.ti_status == TI_STATE_RUNNING) {
			if (!set_task(WORK_Timed, time_now + spread_afslog_signal, redo_afslog, (void *)ptask)) {
				log_record(PBSEVENT_ERROR, PBS_EVENTCLASS_JOB, LOG_ERR,
					pjob->ji_qs.ji_jobid, "unable to set afslog task");
			}

			spread_afslog_signal += 10; /* interval 10 seconds */
		}
	}
#endif

	return PBSGSS_OK;
}

/**
 * @brief
 * 	store_or_update_cred - save received credentials into mom's memory
 *
 * @param[in] jobid - Job ID
 * @param[in] princ - principal - owner of the job
 * @param[in] data - the credentials itself
 * @param[in] data_base64 - the credentials in base64
 *
 */
void store_or_update_cred(char *jobid, char *princ, krb5_data *data, char *data_base64) {
	svrcred_data *cred_data;

	cred_data = (svrcred_data *)GET_NEXT(svr_allcreds);
	while (cred_data) {
		if (strcmp(cred_data->cr_jobid, jobid) == 0) {
			free(cred_data->cr_data->data);
			free(cred_data->cr_data);
			if (cred_data->cr_data_base64)
				free(cred_data->cr_data_base64);

			cred_data->cr_data = data;
			cred_data->cr_data_base64 = data_base64;
			return;
		}
		cred_data = (svrcred_data *)GET_NEXT(cred_data->cr_link);
	}

	if ((cred_data = (svrcred_data *)malloc(sizeof(svrcred_data))) == NULL) {
		log_err(errno, __func__, "Unable to allocate Memory!\n");
		return;
	}

	CLEAR_LINK(cred_data->cr_link);

	cred_data->cr_jobid = strdup(jobid);
	cred_data->cr_princ = strdup(princ);
	cred_data->cr_data = data;
	cred_data->cr_data_base64 = data_base64;

	append_link(&svr_allcreds, &cred_data->cr_link, cred_data);
}

/**
 * @brief
 * 	delete_cred - delete credentials associated with job id from the mom's
 *	memory
 *
 * @param[in] jobid - Job ID
 *
 */
void delete_cred(char *jobid) {
	svrcred_data *cred_data;

	cred_data = (svrcred_data *)GET_NEXT(svr_allcreds);
	while (cred_data) {
		if (strcmp(cred_data->cr_jobid, jobid) == 0) {
			free(cred_data->cr_jobid);
			free(cred_data->cr_princ);
			free(cred_data->cr_data->data);
			free(cred_data->cr_data);
			if (cred_data->cr_data_base64)
				free(cred_data->cr_data_base64);

			delete_link(&cred_data->cr_link);
			return;
		}
		cred_data = (svrcred_data *)GET_NEXT(cred_data->cr_link);
	}
}

/**
 * @brief
 * 	find_cred_by_jobid - try to find credentials in mom's memory by the jobid
 *
 * @param[in] jobid - Job ID
 *
 * @return 	krb5_data
 * @retval	credentials data on success
 * @retval	NULL otherwise
 */
krb5_data *find_cred_by_jobid(char *jobid) {
	svrcred_data *cred_data;

	cred_data = (svrcred_data *)GET_NEXT(svr_allcreds);
	while (cred_data) {
		if (strcmp(cred_data->cr_jobid, jobid) == 0)
			return cred_data->cr_data;

		cred_data = (svrcred_data *)GET_NEXT(cred_data->cr_link);
	}
	return NULL;
}

/**
 * @brief
 * 	find_cred_by_princ - try to find credentials in mom's memory by the principal
 *
 * @param[in] princ - principal
 *
 * @return 	krb5_data
 * @retval	credentials data on success
 * @retval	NULL otherwise
 */
krb5_data *find_cred_by_princ(char *princ) {
	svrcred_data *cred_data;

	cred_data = (svrcred_data *)GET_NEXT(svr_allcreds);
	while (cred_data) {
		if (strcmp(cred_data->cr_princ, princ) == 0)
			return cred_data->cr_data;

		cred_data = (svrcred_data *)GET_NEXT(cred_data->cr_link);
	}
	return NULL;
}

/**
 * @brief
 * 	find_base64_cred_by_jobid - try to find credentials in mom's memory
 *	by the jobid
 *
 * @param[in] jobid - Job ID
 *
 * @return 	char
 * @retval	credentials data in base64 on success
 * @retval	NULL otherwise
 */
char *find_base64_cred_by_jobid(char *jobid) {
	svrcred_data *cred_data;

	cred_data = (svrcred_data *)GET_NEXT(svr_allcreds);
	while (cred_data) {
		if (strcmp(cred_data->cr_jobid, jobid) == 0)
			return cred_data->cr_data_base64;

		cred_data = (svrcred_data *)GET_NEXT(cred_data->cr_link);
	}
	return NULL;
}

/**
 * @brief
 * 	im_cred_send - send job's credentials from superior mom to sister mom.
 *	Find the credentials in base64 in superior mom's memory and send them
 *	via IM protocol. This function is meant to by run by send_sisters and
 *	it shouldn't be sent via mcast because mcast can't be wrapped by GSS
 *
 * @param[in] jobid - Job ID
 *
 * @return 	int
 * @retval	DIS_SUCCESS on success
 * @retval	!= DIS_SUCCESS otherwise
 */
int im_cred_send(job *pjob, hnodent *xp, int stream) {
	int	ret;
	char	*data_base64;

	data_base64 = find_base64_cred_by_jobid(pjob->ji_qs.ji_jobid);

	if (data_base64 == NULL) {
		ret = DIS_PROTO;
		goto done;
	}

	ret = diswst(stream, data_base64);
	if (ret != DIS_SUCCESS)
		goto done;

	return DIS_SUCCESS;

done:
	sprintf(log_buffer, "dis err %d (%s)", ret, dis_emsg[ret]);
	DBPRT(("%s: %s\n", __func__, log_buffer))
	log_joberr(-1, __func__, log_buffer, pjob->ji_qs.ji_jobid);
	return ret;
}

/**
 * @brief
 * 	im_cred_read - read received (via IM) credentials in base64 on sister
 *	mom, store the credentials in mom's memory and renew the credentials for
 *	associated job.
 *
 * @param[in] pjob - job structure
 * @param[in] np - node structure
 * @param[in] stream - tpp channel
 *
 * @return 	int
 * @retval	DIS_SUCCESS on success
 * @retval	!= DIS_SUCCESS otherwise
 */
int im_cred_read(job *pjob, hnodent *np, int stream) {
	int	ret;
	char	*data_base64;
	unsigned char	out_data[CRED_DATA_SIZE];
	ssize_t		out_len = 0;
	char		msg[MSG_SIZE];
	ssize_t		msg_len = 0;
	krb5_data	*data;

	DBPRT(("%s: entry\n", __func__))
	data_base64 = disrst(stream, &ret);
	if (ret != DIS_SUCCESS)
		goto err;

	if (decode_block_base64((unsigned char *)data_base64, strlen(data_base64), out_data, &out_len, msg, msg_len) != 0) {
		log_err(errno, __func__, msg);
		ret = DIS_PROTO;
		goto err;
	}

	if ((data = (krb5_data *)malloc(sizeof(krb5_data))) == NULL) {
		log_err(errno, __func__, "Unable to allocate Memory!\n");
		ret = DIS_NOMALLOC;
		goto err;
	}

	if ((data->data = (char *)malloc(sizeof(unsigned char)*out_len)) == NULL) {
		log_err(errno, __func__, "Unable to allocate Memory!\n");
		ret = DIS_NOMALLOC;
		goto err;
	}

	data->length = out_len;
	memcpy(data->data,out_data, out_len);

	log_event(PBSEVENT_DEBUG, PBS_EVENTCLASS_JOB,
		LOG_INFO,
		pjob->ji_qs.ji_jobid,
		"credentials from superior mom received");

	store_or_update_cred(pjob->ji_qs.ji_jobid,
		pjob->ji_wattr[(int)JOB_ATR_krb_princ].at_val.at_str,
		data,
		NULL);

	/* I am the sister and new cred has been received - lets renew creds */
	renew_job_cred(pjob);

	return DIS_SUCCESS;

err:
	/*
	 ** Getting here means we had a read failure.
	 */
	sprintf(log_buffer, "dis err %d (%s)", ret, dis_emsg[ret]);
	DBPRT(("%s: %s\n", __func__, log_buffer))
	log_joberr(-1, __func__, log_buffer, pjob->ji_qs.ji_jobid);
	return ret;
}

/**
 * @brief
 * 	send_cred_sisters - send credentials from superior mom to all sister moms
 *
 * @param[in] pjob - job structure
 *
 */
void send_cred_sisters(job *pjob) {
	int i;

	if (pjob->ji_numnodes > 1) {
		log_event(PBSEVENT_DEBUG, PBS_EVENTCLASS_JOB,
			LOG_INFO,
			pjob->ji_qs.ji_jobid,
			"sending credentials to sisters");

		i = send_sisters(pjob, IM_CRED, im_cred_send);

		if (i != pjob->ji_numnodes-1) {
			//(void)set_task(WORK_Timed, time_now + 2, send_cred_sisters, pjob);

			log_record(PBSEVENT_ERROR, PBS_EVENTCLASS_JOB, LOG_ERR,
				pjob->ji_qs.ji_jobid,
				"could not send credentials to sisters");
		}
	}
}

#if defined(HAVE_LIBKAFS) || defined(HAVE_LIBKOPENAFS)
static volatile sig_atomic_t rec_signal = 0;
static volatile struct krb_holder *afslog_ticket;

/**
 * @brief
 * 	do_afslog_on_signal - AFS log signal handler
 *
 * @param[in] signal - received signal
 *
 */
static void do_afslog_on_signal(int signal) {
	krb5_error_code ret;

	if (signal == SIGHUP) {
		if ((ret = do_afslog(afslog_ticket->context, afslog_ticket->job_info))) {
			return;
		}
	} else {
		rec_signal = signal;
	}
}

/**
 * @brief
 * 	wait_afslog - in AFS log process wait for signal HUP for do AFS log or
 *	0 for terminate
 *
 * @param[in] signal - received signal
 *
 */
static void wait_afslog() {
	// initialize signal catcher
	struct sigaction sa;
	memset(&sa, 0, sizeof(sa));
	sa.sa_handler = do_afslog_on_signal;
	sigaction(SIGTERM, &sa, NULL);
	sa.sa_handler = do_afslog_on_signal;
	sigaction(SIGHUP, &sa, NULL);

	while (rec_signal == 0) {
		sleep(TIME_SLEEP);
	}
}

/**
 * @brief
 * 	start_afslog - fork AFS log process for a specific job task,
 *	save PID file and do AFS log for the task. The AFS log need to be done
 *	in the child of original process who set the pag.
 *
 * @param[in] ptask - job task
 * @param[in] ticket - kerberos ticket associated with process
 * @param[in] fd1 - read socket - need to be closed in forked process
 * @param[in] fd2 - write socker - need to be closed in forked process
 *
 * @return 	int
 * @retval	PBSGSS_OK on success
 * @retval	!= PBSGSS_OK otherwise
 */
int start_afslog(const task *ptask, struct krb_holder *ticket, int fd1, int fd2) {
	char buf[MSG_SIZE] ;
	char strerrbuf[MSG_SIZE] ;
	int ret = PBSGSS_OK;
	char pid_file[MAXPATHLEN];
	int local_ticket = 0;

	if(!k_hasafs())
		return PBSGSS_OK;

	if (ptask == NULL)
		return PBSGSS_ERR_INTERNAL;

	job *pjob = ptask->ti_job;

	if (ticket == NULL) {
		ticket = alloc_ticket();
		if (ticket == NULL)
			return PBSGSS_ERR_INTERNAL;

		if ((ret = init_ticket_from_ccache(pjob, NULL, ticket)) != PBSGSS_OK) {
			if (local_ticket)
				free_ticket(ticket, CRED_RENEWAL);

			/* job without a principal */
			/* not an error, but do nothing */
			if (ret == PBSGSS_ERR_NO_KRB_PRINC)
				return PBSGSS_OK;

			return ret;
		}

		local_ticket = 1;
	}

	afslog_ticket = ticket;

	if (*pjob->ji_qs.ji_fileprefix != '\0')
		snprintf(pid_file, sizeof(pid_file), "%s%s_afslog_%8.8X.pid", path_jobs, pjob->ji_qs.ji_fileprefix, (unsigned int)ptask->ti_qs.ti_task);
	else
		snprintf(pid_file, sizeof(pid_file), "%s%s_afslog_%8.8X.pid", path_jobs, pjob->ji_qs.ji_jobid, (unsigned int)ptask->ti_qs.ti_task);

	int fd = open(pid_file, O_CREAT|O_EXCL|O_WRONLY, 0600);
	if (fd == -1) {
		/* another afslog process is running ? */
		snprintf(buf, sizeof(buf), "opening PID file for afslog process (%s) uid = %d", pid_file, getuid());
		log_err(errno, __func__, buf);
		return PBSGSS_ERR_CANT_OPEN_FILE;
	}

	/* Go user */
	if(seteuid(ticket->job_info->job_uid) < 0) {
		strerror_r(errno ,strerrbuf, sizeof(strerrbuf));
		snprintf(buf, sizeof(buf), "Could not set uid using \"setuid()\": %s.", strerrbuf);
		log_err(errno, __func__, buf);

		return PBSGSS_ERR_INTERNAL;
	}

	k_setpag();

	do_afslog(afslog_ticket->context, afslog_ticket->job_info);

	int pid = fork();
	if (pid < 0) {
		/* Go root on error */
		if(seteuid(0) < 0) {
			strerror_r(errno ,strerrbuf, sizeof(strerrbuf));
			snprintf(buf, sizeof(buf), "Could not reset root priviledges: %s.", strerrbuf);
			log_err(errno, __func__, buf);

			return PBSGSS_ERR_INTERNAL;
		}

		log_err(errno, __func__, "fork() failed");
		close(fd);

		return PBSGSS_ERR_INTERNAL;
	}

	if (pid > 0) {
		/* Go root in parent */
		if(seteuid(0) < 0) {
			strerror_r(errno ,strerrbuf, sizeof(strerrbuf));
			snprintf(buf, sizeof(buf), "Could not reset root priviledges: %s.", strerrbuf);
			log_err(errno, __func__, buf);

			return PBSGSS_ERR_INTERNAL;
		}

		snprintf(buf, sizeof(buf), "%d\n", pid);
		ret = write(fd, buf, strlen(buf));
		if (ret == -1) {
			log_err(errno, __func__, "writing pid failed");
			goto out;
		}
		sprintf(log_buffer, "afslog for task %8.8X started, pid: %d",
			ptask->ti_qs.ti_task, pid);
		log_record(PBSEVENT_DEBUG, PBS_EVENTCLASS_JOB, LOG_DEBUG, pjob->ji_qs.ji_jobid, log_buffer);
		ret = PBSGSS_OK;

		out:
			if (fd != -1) {
				fsync(fd);
				close(fd);
			}

		if (local_ticket)
			free_ticket(ticket, CRED_RENEWAL);

		return ret;
	}

	close(fd);

	if (fd1 >= 0)
		close(fd1);
	if (fd2 >= 0)
		close(fd2);

	if (setsid() == -1)
		log_record(PBSEVENT_ERROR, PBS_EVENTCLASS_JOB, LOG_ERR, pjob->ji_qs.ji_jobid, "afslog could not setsid");

	wait_afslog();

	if (local_ticket)
		free_ticket(ticket, CRED_RENEWAL);

	exit(0);
}

/**
 * @brief
 * 	signal_afslog - send signal to the specific job task in order to do
 *	AFS log or terminate the process on job exit.
 *
 * @param[in] ptask - job task
 * @param[in] signal - signal to send
 *
 * @return 	int
 * @retval	PBSGSS_OK on success
 * @retval	!= PBSGSS_OK otherwise
 */
int signal_afslog(const task *ptask, int signal) {
	char buf[MSG_SIZE] ;
	char pid_file[MAXPATHLEN];
	FILE *fd;
	struct stat cache_info;

	if (ptask == NULL)
		return PBSGSS_ERR_INTERNAL;

	job *pjob = ptask->ti_job;
	if (pjob == NULL)
		return PBSGSS_ERR_INTERNAL;

	if (*pjob->ji_qs.ji_fileprefix != '\0')
		snprintf(pid_file, sizeof(pid_file), "%s%s_afslog_%8.8X.pid", path_jobs, pjob->ji_qs.ji_fileprefix, (unsigned int)ptask->ti_qs.ti_task);
	else
		snprintf(pid_file, sizeof(pid_file), "%s%s_afslog_%8.8X.pid", path_jobs, pjob->ji_qs.ji_jobid, (unsigned int)ptask->ti_qs.ti_task);

	fd = fopen(pid_file, "r");
	if (fd == NULL) {
		snprintf(buf, sizeof(buf), "Failed to open pidfile: %s", pid_file);
		log_err(errno, __func__, buf);

		return PBSGSS_ERR_CANT_OPEN_FILE;
	}

	int pid = 0;
	if (fscanf(fd, "%d", &pid) < 1) {
			pid = -1;
	}

	fclose(fd);

	if (pid >= 0) {
		if (kill(pid, signal) != 0) {
			snprintf(buf, sizeof(buf), "afslog for task %8.8X could not send signal %d to PID %d.",
				(unsigned int)ptask->ti_qs.ti_task, signal, pid);
			log_err(errno, __func__, buf);

			return PBSGSS_ERR_KILL_RENEWAL_PROCESS;
		} else {
			sprintf(log_buffer, "afslog for task %8.8X, signal %d sent to pid %d",
				(unsigned int)ptask->ti_qs.ti_task, signal, pid);
			log_record(PBSEVENT_DEBUG, PBS_EVENTCLASS_JOB, LOG_DEBUG, pjob->ji_qs.ji_jobid, log_buffer);
		}
	} else {
		snprintf(buf, sizeof(buf), "afslog for task %8.8X failed to get pid from pidfile: %s",
			(unsigned int)ptask->ti_qs.ti_task, pid_file);
		log_err(errno, __func__, buf);

		return PBSGSS_ERR_KILL_RENEWAL_PROCESS;
	}

	if (signal != SIGHUP && stat(pid_file, &cache_info) == 0) {
		unlink(pid_file);
	}

	return PBSGSS_OK;
}

/**
 * @brief
 * 	getpag - recognize pag between groups and return the pag.
 *
 * @param[in] ptask - job task
 * @param[in] signal - signal to send
 *
 * @return 	int32_t
 * @retval	pag on success
 * @retval	0 otherwise
 */
int32_t getpag() {
	gid_t *grplist = NULL;
	int    i;
	int    numsup;
	static int   maxgroups = 0;
	int32_t pag = 0;

	maxgroups = (int)sysconf(_SC_NGROUPS_MAX);

	grplist = calloc((size_t)maxgroups, sizeof(gid_t));
	if (grplist == NULL)
		return 0;

	numsup = getgroups(maxgroups, grplist);

	for (i = 0; i < numsup; ++i) {
		/* last (4th) byte in pag is char 'A' */
		if ((grplist[i] >> 24) == 'A') {
			pag = grplist[i];
			break;
		}
	}

	if (grplist)
		free(grplist);

	return pag;
}
#endif

#if defined(KRB525_FALLBACK)
/** Acquire a user ticket from the host ticket using krb525
 *
 * @param ticket Ticket to acquire
 * @param errbuf Error buffer
 * @param errbufsz Size of error buffer
 * @return krb5 error code
 */
static krb5_error_code get_ticket_krb525(struct krb_holder *ticket, char *errbuf, size_t errbufsz) {
	krb5_principal  pbs_service, local_tgs, remote_tgs;
	krb5_ccache     ccache;
	krb5_keytab     keytab = NULL;
	krb5_error_code ret = 0;

	//ticket->job_info.ccache
	//ticket->job_info.creds
	//ticket->job_info.client

	char *name = NULL;

	/* get our principal */
	if((ret=krb5_sname_to_principal(ticket->context, NULL, PBS_SERVICE, KRB5_NT_SRV_HST, &pbs_service))) {
		const char *krb5_err = krb5_get_error_message(ticket->context,ret);
		snprintf(errbuf,errbufsz,"krb5_get_ticket - couldn't get client principal - (%s)",krb5_err);
		krb5_free_error_message(ticket->context,krb5_err);
		return(ret);
	}

	/* create TGS principal */
	if((ret = krb5_make_principal(ticket->context, &local_tgs, pbs_service->realm, KRB5_TGS_NAME, pbs_service->realm, NULL))) {
		const char *krb5_err = krb5_get_error_message(ticket->context,ret);
		snprintf(errbuf,errbufsz,"krb5_get_ticket - couldn't create principal - (%s)",krb5_err);
		krb5_free_error_message(ticket->context,krb5_err);
		krb5_free_principal(ticket->context,pbs_service);
		return(ret);
	}

	/* Create memory cache */
	if((ret = krb5_cc_new_unique(ticket->context, krb5_mcc_ops.prefix, NULL, &ccache))) {
		const char *krb5_err = krb5_get_error_message(ticket->context,ret);
		snprintf(errbuf,errbufsz,"krb5_get_ticket - couldn't create credential cache - (%s)",krb5_err);
		krb5_free_error_message(ticket->context,krb5_err);
		krb5_free_principal(ticket->context,pbs_service);
		krb5_free_principal(ticket->context,local_tgs);
		return(ret);
	}

	/* Initialize the cache */
	if((ret = krb5_cc_initialize(ticket->context, ccache, pbs_service))) {
		const char *krb5_err = krb5_get_error_message(ticket->context,ret);
		snprintf(errbuf,errbufsz,"krb5_get_ticket - couldn't initialize credentials cache - (%s)",krb5_err);
		krb5_free_error_message(ticket->context,krb5_err);
		goto out;
	}

	if ((ret = krb5_kt_default(ticket->context, &keytab)) != 0) {
		const char *krb5_err = krb5_get_error_message(ticket->context,ret);
		snprintf(errbuf,errbufsz,"krb5_get_ticket - couldn't get default keytab - (%s)",krb5_err);
		krb5_free_error_message(ticket->context,krb5_err);
		goto out;
	}

	if ((ret = krb5_unparse_name(ticket->context, local_tgs, &name)) != 0) {
		const char *krb5_err = krb5_get_error_message(ticket->context,ret);
		snprintf(errbuf,errbufsz,"krb5_get_ticket - couldn't un-parse client name - (%s)",krb5_err);
		krb5_free_error_message(ticket->context,krb5_err);
		goto out;
	}

	{ // get credentials and store them in the cache
	krb5_creds *creds;
	// initialize local credential variable
	creds = malloc(sizeof(krb5_creds));
	if (creds == NULL)
		return PBSGSS_ERR_INTERNAL;
	memset(creds,0,sizeof(krb5_creds));

	creds->flags.b.forwardable = krb5_config_get_bool(ticket->context, NULL, "libdefaults", "forwardable", NULL);

	krb5_get_init_creds_opt *opts;
	krb5_get_init_creds_opt_alloc(ticket->context,&opts);
	krb5_get_init_creds_opt_set_tkt_life(opts,TIME_LIFETIME);
	krb5_get_init_creds_opt_set_renew_life(opts,TIME_LIFETIME);
	krb5_get_init_creds_opt_set_forwardable(opts,creds->flags.b.forwardable);

	krb5_boolean b;
	krb5_appdefault_boolean(ticket->context, NULL, NULL, "no-addresses", FALSE, &b);
	krb5_get_init_creds_opt_set_addressless(ticket->context,opts,b);

	krb5_preauthtype pa_types[] = { KRB5_PADATA_ENC_TIMESTAMP, KRB5_PADATA_NONE };
	krb5_get_init_creds_opt_set_preauth_list(opts,pa_types,2);


	if ((ret = krb5_get_init_creds_keytab(ticket->context, creds, pbs_service, keytab, 0, name, opts)) != 0) {
		const char *krb5_err = krb5_get_error_message(ticket->context,ret);
		snprintf(errbuf,errbufsz,"krb5_get_ticket - couldn't initialize credentials - (%s)",krb5_err);
		krb5_free_error_message(ticket->context,krb5_err);

		krb5_free_creds(ticket->context,creds);
		krb5_get_init_creds_opt_free(ticket->context,opts);
		goto out;
	}

	if ((krb5_cc_store_cred(ticket->context, ccache, creds)) != 0) {
		const char *krb5_err = krb5_get_error_message(ticket->context,ret);
		snprintf(errbuf,errbufsz,"krb5_get_ticket - couldn't store credentials - (%s)",krb5_err);
		krb5_free_error_message(ticket->context,krb5_err);

		krb5_free_creds(ticket->context,creds);
		krb5_get_init_creds_opt_free(ticket->context,opts);
		goto out;
	}

	krb5_free_creds(ticket->context,creds);
	krb5_get_init_creds_opt_free(ticket->context,opts);
	}


	/* convert our TGT to users TGT:
	 *   source ticket: pbs/<hostname>@LOCAL_REALM for krbtgt/REALM@REALM
	 *   dest.  ticket: user@REALM for krbtgt/REALM@REALM
	 * we have pbs/<hostname>@LOCAL_REALM for krbtgt/LOCAL_REALM@LOCAL_REALM
	 */

	krb5_creds *creds;
	// initialize local credential variable
	creds = malloc(sizeof(krb5_creds));
	if (creds == NULL)
		return PBSGSS_ERR_INTERNAL;
	memset(creds,0,sizeof(krb5_creds));

	if((ret = krb5_copy_principal(ticket->context, pbs_service, &creds->client))) {
		const char *krb5_err = krb5_get_error_message(ticket->context,ret);
		snprintf(errbuf,errbufsz,"krb5_get_ticket - couldn't copy client principal - (%s)",krb5_err);
		krb5_free_error_message(ticket->context,krb5_err);
		goto out;
	}

	/* Create TGS principal (possibly in another realm) */
	if((ret = krb5_make_principal(ticket->context, &remote_tgs, ticket->job_info->realm, KRB5_TGS_NAME, ticket->job_info->realm, NULL))) {
		const char *krb5_err = krb5_get_error_message(ticket->context,ret);
		snprintf(errbuf,errbufsz,"krb5_get_ticket - couldn't construct server principal - (%s)",krb5_err);
		krb5_free_error_message(ticket->context,krb5_err);
		goto out;
	}

	if((ret = krb5_copy_principal(ticket->context, remote_tgs, &creds->server))) {
		const char *krb5_err = krb5_get_error_message(ticket->context,ret);
		snprintf(errbuf,errbufsz,"krb5_get_ticket - couldn't copy server principal - (%s)",krb5_err);
		krb5_free_error_message(ticket->context,krb5_err);
		goto out;
	}

	krb5_creds *my_creds = NULL;

	krb5_kdc_flags flags;
	flags.i = 0;
	flags.b.forwardable = krb5_config_get_bool(ticket->context, NULL, "libdefaults", "forwardable", NULL);

	/* Get credentials */
	if((ret = krb5_get_credentials_with_flags(ticket->context, 0, flags, ccache, creds, &my_creds))) {
		const char *krb5_err = krb5_get_error_message(ticket->context,ret);
		snprintf(errbuf,errbufsz,"krb5_get_ticket - couldn't get server credentials - (%s)",krb5_err);
		krb5_free_error_message(ticket->context,krb5_err);
		goto out;
	}

	/* set target client */
	if((ret = krb5_copy_principal(ticket->context, ticket->job_info->client, &ticket->job_info->creds->client))) {
		const char *krb5_err = krb5_get_error_message(ticket->context,ret);
		snprintf(errbuf,errbufsz,"krb5_get_ticket - couldn't copy client principal - (%s)",krb5_err);
		krb5_free_error_message(ticket->context,krb5_err);
		goto out;
	}

	/* set target server */
	if((ret = krb5_copy_principal(ticket->context, remote_tgs, &ticket->job_info->creds->server))) {
		const char *krb5_err = krb5_get_error_message(ticket->context,ret);
		snprintf(errbuf,errbufsz,"krb5_get_ticket - couldn't copy server principal - (%s)",krb5_err);
		krb5_free_error_message(ticket->context,krb5_err);
		goto out;
	}

	if ((ret = krb525_get_creds_ccache(ticket->context, ccache, my_creds, ticket->job_info->creds)) != 0) {
		snprintf(errbuf,errbufsz, "krb5_get_ticket - converting credentials; Error text: %s", krb525_convert_error);
		goto out;
	}

	ticket->job_info->endtime = ticket->job_info->creds->times.endtime;

out:
	krb5_free_creds(ticket->context,creds);
	krb5_free_creds(ticket->context,my_creds);
	free(name);
	krb5_kt_close(ticket->context, keytab);
	krb5_free_principal(ticket->context,pbs_service);
	krb5_free_principal(ticket->context,local_tgs);
	krb5_free_principal(ticket->context,remote_tgs);
	krb5_cc_destroy(ticket->context, ccache);

	return(ret);
}

void krb525_fallback_renewal(struct work_task *pwt) {
	char *jobid = (char *)pwt->wt_parm1;
	job *pjob;
	int ret = -1;
	int krb525_fallback_time;
	struct krb_holder *ticket;

	if ((pjob = find_job(jobid)) != NULL) {
		ticket = alloc_ticket();

		if (ticket != NULL) {
			if ((ret = init_ticket_from_ccache(pjob, NULL, ticket)) == PBSGSS_OK) {
				if (ticket->job_info->endtime - KRB525_FALLBACK_LIFETIME < time_now) {
					log_record(PBSEVENT_JOB, PBS_EVENTCLASS_JOB, LOG_DEBUG, pjob->ji_qs.ji_jobid,
						"krb525_fallback: ticket too old, renewing");
					ret = renew_job_cred(pjob);
				}
			} else {
				/* failed to get cred from ccache - get a new one */
				ret = renew_job_cred(pjob);
			}

			free_ticket(ticket, CRED_RENEWAL);
		}

		if (ret) {
			log_record(PBSEVENT_ERROR, PBS_EVENTCLASS_JOB, LOG_ERR,
				pjob->ji_qs.ji_jobid, "krb525_fallback failed");
			krb525_fallback_time = time_now + KRB525_FALLBACK_RETRY;
		} else {
			krb525_fallback_time = time_now + KRB525_FALLBACK_TIME;
		}

		if (!set_task(WORK_Timed, krb525_fallback_time,
			krb525_fallback_renewal,
			(void *)jobid)) {
			log_record(PBSEVENT_ERROR, PBS_EVENTCLASS_JOB, LOG_ERR,
				pjob->ji_qs.ji_jobid, "unable to set krb525_fallback task");
		}
	} else {
		/* job not found -> already finished */
		free(jobid); /* we allocated the jobid on first wt setup, lets free it */
	}
}
#endif /* krb525 */

#endif