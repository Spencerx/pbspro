/*
 * Copyright (C) 1994-2019 Altair Engineering, Inc.
 * For more information, contact Altair at www.altair.com.
 *
 * This file is part of the PBS Professional ("PBS Pro") software.
 *
 * Open Source License Information:
 *
 * PBS Pro is free software. You can redistribute it and/or modify it under the
 * terms of the GNU Affero General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any
 * later version.
 *
 * PBS Pro is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Commercial License Information:
 *
 * For a copy of the commercial license terms and conditions,
 * go to: (http://www.pbspro.com/UserArea/agreement.html)
 * or contact the Altair Legal Department.
 *
 * Altair’s dual-license business model allows companies, individuals, and
 * organizations to create proprietary derivative works of PBS Pro and
 * distribute them - whether embedded or bundled with other software -
 * under a commercial license agreement.
 *
 * Use of Altair’s trademarks, including but not limited to "PBS™",
 * "PBS Professional®", and "PBS Pro™" and Altair’s logos is subject to Altair's
 * trademark licensing policies.
 *
 */

/**
 * @file	krb5_utils.c
 *
 * @brief
 *  Routines providing Kerberos specific routines
 */

#include <pbs_config.h>   /* the master config generated by configure */

#if defined(PBS_SECURITY) && (PBS_SECURITY == KRB5)

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <time.h>
#include <krb5.h>

#include <pbs_ifl.h>

#include "log.h"
#include "pbsgss.h"

/**
 * @brief
 * 	create or renew ccache from keytab for the gss client side.
 *
 * @return 	int
 * @retval	0 on success
 * @retval	!= 0 otherwise
 */
int init_pbs_client_ccache_from_keytab() {
	krb5_error_code ret;
	krb5_context context = NULL;
	krb5_principal pbs_service = NULL;
	krb5_keytab keytab = NULL;
	krb5_creds *creds = NULL;
	krb5_get_init_creds_opt *opt = NULL;
	krb5_ccache ccache = NULL;
	krb5_creds *mcreds = NULL;
	char *realm;
	char **realms = NULL;
	char hostname[PBS_MAXHOSTNAME + 1];
	int endtime = 0;

	creds = malloc(sizeof(krb5_creds));
	memset(creds,0,sizeof(krb5_creds));
	mcreds = malloc(sizeof(krb5_creds));
	memset(mcreds,0,sizeof(krb5_creds));

	setenv("KRB5CCNAME", KRB5_CLIENT_CCNAME, 1);

	ret = krb5_init_context(&context);
	if (ret) {
		snprintf(log_buffer, LOG_BUF_SIZE, "Cannot initialize Kerberos context.\n");
		log_event(PBSEVENT_ERROR, PBS_EVENTCLASS_SERVER, LOG_ERR, __func__, log_buffer);
		goto out;
	}

	ret = krb5_sname_to_principal(context, NULL, KRB5_SERVICE_NAME, KRB5_NT_SRV_HST, &pbs_service);
	if (ret) {
		snprintf(log_buffer, LOG_BUF_SIZE, "Preparing principal failed (%s)\n", krb5_get_error_message(context, ret));
		log_event(PBSEVENT_ERROR, PBS_EVENTCLASS_SERVER, LOG_ERR, __func__, log_buffer);
		goto out;
	}

	ret = krb5_cc_resolve(context, KRB5_CLIENT_CCNAME, &ccache);
	if (ret) {
		snprintf(log_buffer, LOG_BUF_SIZE, "Couldn't resolve ccache name (%s) New ccache will be created.\n", krb5_get_error_message(context, ret));
		log_event(PBSEVENT_ERROR, PBS_EVENTCLASS_SERVER, LOG_ERR, __func__, log_buffer);
		// not an error, we will create new ccache
	}

	ret = gethostname(hostname, PBS_MAXHOSTNAME + 1);
	if (ret) {
		snprintf(log_buffer, LOG_BUF_SIZE, "Failed to get host name\n");
		log_event(PBSEVENT_ERROR, PBS_EVENTCLASS_SERVER, LOG_ERR, __func__, log_buffer);
		goto out;
	}

	ret = krb5_get_host_realm(context, hostname, &realms);
	if (ret) {
		snprintf(log_buffer, LOG_BUF_SIZE, "Failed to get host realms (%s)\n", krb5_get_error_message(context, ret));
		log_event(PBSEVENT_ERROR, PBS_EVENTCLASS_SERVER, LOG_ERR, __func__, log_buffer);
		goto out;
	}

	realm = realms[0];
	ret = krb5_build_principal(context, &mcreds->server, strlen(realm), realm, KRB5_TGS_NAME, realm, NULL);
	if (ret) {
		snprintf(log_buffer, LOG_BUF_SIZE, "Couldn't build server principal (%s)\n", krb5_get_error_message(context, ret));
		log_event(PBSEVENT_ERROR, PBS_EVENTCLASS_SERVER, LOG_ERR, __func__, log_buffer);
		goto out;
	}

	ret = krb5_copy_principal(context, pbs_service, &mcreds->client);
	if (ret) {
		snprintf(log_buffer, LOG_BUF_SIZE, "Couldn't copy client principal (%s)\n", krb5_get_error_message(context, ret));
		log_event(PBSEVENT_ERROR, PBS_EVENTCLASS_SERVER, LOG_ERR, __func__, log_buffer);
		goto out;
	}

	ret = krb5_cc_retrieve_cred(context, ccache, 0, mcreds, creds);
	if (ret) {
		snprintf(log_buffer, LOG_BUF_SIZE, "Couldn't retrieve credentials from cache (%s) New ccache will be created.\n", krb5_get_error_message(context, ret));
		log_event(PBSEVENT_ERROR, PBS_EVENTCLASS_SERVER, LOG_ERR, __func__, log_buffer);
		// not an error, we will create new ccache
	} else {
		endtime = creds->times.endtime;
	}

	if (endtime - 60*30 >= time(NULL)) {
		ret = 0;
		goto out;
	}

	ret = krb5_cc_new_unique(context, "FILE", NULL, &ccache);
	if (ret) {
		snprintf(log_buffer, LOG_BUF_SIZE, "Failed to create ccache (%s)\n", krb5_get_error_message(context, ret));
		log_event(PBSEVENT_ERROR, PBS_EVENTCLASS_SERVER, LOG_ERR, __func__, log_buffer);
		goto out;
	}

	ret = krb5_cc_resolve(context, KRB5_CLIENT_CCNAME, &ccache);
	if (ret) {
		snprintf(log_buffer, LOG_BUF_SIZE, "Couldn't resolve cache name (%s)\n", krb5_get_error_message(context, ret));
		log_event(PBSEVENT_ERROR, PBS_EVENTCLASS_SERVER, LOG_ERR, __func__, log_buffer);
		goto out;
	}

	ret = krb5_kt_default(context, &keytab);
	if (ret) {
		snprintf(log_buffer, LOG_BUF_SIZE, "Couldn't open keytab (%s)\n", krb5_get_error_message(context, ret));
		log_event(PBSEVENT_ERROR, PBS_EVENTCLASS_SERVER, LOG_ERR, __func__, log_buffer);
		goto out;
	}
	ret = krb5_get_init_creds_opt_alloc(context, &opt);
	if (ret) {
		snprintf(log_buffer, LOG_BUF_SIZE, "Couldn't allocate a new initial credential options structure (%s)\n", krb5_get_error_message(context, ret));
		log_event(PBSEVENT_ERROR, PBS_EVENTCLASS_SERVER, LOG_ERR, __func__, log_buffer);
		goto out;
	}

	krb5_get_init_creds_opt_set_forwardable(opt, 1);

	ret = krb5_get_init_creds_keytab(context, creds, pbs_service, keytab, 0, NULL, opt);
	if (ret) {
		snprintf(log_buffer, LOG_BUF_SIZE, "Couldn't get initial credentials using a key table (%s)\n", krb5_get_error_message(context, ret));
		log_event(PBSEVENT_ERROR, PBS_EVENTCLASS_SERVER, LOG_ERR, __func__, log_buffer);
		goto out;
	}

	ret = krb5_cc_initialize(context, ccache, creds->client);
	if (ret) {
		snprintf(log_buffer, LOG_BUF_SIZE, "Credentials cache initializing failed (%s)\n", krb5_get_error_message(context, ret));
		log_event(PBSEVENT_ERROR, PBS_EVENTCLASS_SERVER, LOG_ERR, __func__, log_buffer);
		goto out;
	}

	ret = krb5_cc_store_cred(context, ccache, creds);
	if (ret) {
		snprintf(log_buffer, LOG_BUF_SIZE, "Couldn't store ccache (%s)\n", krb5_get_error_message(context, ret));
		log_event(PBSEVENT_ERROR, PBS_EVENTCLASS_SERVER, LOG_ERR, __func__, log_buffer);
		goto out;
	}

out:
	if (creds)
		krb5_free_creds(context, creds);
	if (mcreds)
		krb5_free_creds(context, mcreds);
	if (opt)
		krb5_get_init_creds_opt_free(context, opt);
	if (pbs_service)
		krb5_free_principal(context, pbs_service);
	if (ccache)
		krb5_cc_close(context, ccache);
	if (realms)
		krb5_free_host_realm(context, realms);
	if (keytab)
		krb5_kt_close(context, keytab);
	if (context)
		krb5_free_context(context);
	return (ret);
}

#endif